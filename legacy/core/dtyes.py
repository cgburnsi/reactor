''' core/dtypes.py 
    ------------------
    Data Structures (Storage Arrays) Definitions Used by SnapMesh
    
    This module defines the structured NumPy arrays data types used to store:
        
    - Mesh Generation Data
        1 - TOPOLOGY DATA (Nodes, Faces, and Cells)
        2 - CONSTRAINTS (Geometry)
        3 - MANIPULATION (Field Density Changes)
        
    These structures are used across throughout the SnapMesh code.
    
    Key Concepts:
    - IDs are typically 1-based (matching the input file).
    - Indices (if derived) are 0-based.
    - 'segments' in FACE_DTYPE controls the Locked Boundary logic.
    - 'sources' drive the Sizing Field gradient.
'''
import numpy as np

# -----------------------------------------------------------------------------
# 1. Topology Elements (Nodes, Faces, Cells)
# -----------------------------------------------------------------------------

# NODES: The fundamental vertices of the mesh.
NODE_DTYPE = np.dtype([
    ('id', 'i4'),       # Unique Node Identifier (Input File ID)
    ('x',  'f8'),       # X-Coordinate (float64)
    ('y',  'f8')        # Y-Coordinate (float64)
])

# FACES: The boundary edges connecting two nodes.
FACE_DTYPE = np.dtype([
    ('id',  'i4'),      # Unique Face Identifier
    ('n1',  'i4'),      # Start Node ID
    ('n2',  'i4'),      # End Node ID
    ('tag', 'i4'),      # Boundary Condition Tag
    ('ctag', 'i4'),     # Constraint Tag (0 = Straight Line)
    ('segments', 'i4')  # LOCKED COUNT: The exact number of edges to generate 
                        # on this face. If > 0, the boundary is "locked".
])

# CELLS: The triangular elements generated by the solver.
CELL_DTYPE = np.dtype([
    ('id', 'i4'),       # Unique Cell Identifier
    ('f1', 'i4'),       # Neighbor/Face 1
    ('f2', 'i4'),       # Neighbor/Face 2
    ('f3',  'i4')       # Neighbor/Face 3
])

# -----------------------------------------------------------------------------
# 2. Constraints (Geometric and Boundaries)
# -----------------------------------------------------------------------------

# CONSTRAINTS: Geometric shapes that faces project onto.
CONSTRAINT_DTYPE = np.dtype([
    ('id', 'i4'),       # Constraint ID
    ('type', 'i4'),     # Type Marker: 1=Line, 2=Circle/Arc
    ('p1', 'f8'),       # Parameter 1 (e.g., Center X or Line Start)
    ('p2', 'f8'),       # Parameter 2 (e.g., Center Y or Line End)
    ('p3', 'f8'),       # Parameter 3 (e.g., Radius or ignored)
    ('p4', 'f8'),       # Parameter 3 (e.g., Radius or ignored)
    ('p5', 'f8')        # Parameter 3 (e.g., Radius or ignored)

])


BC_DTYPE = np.dtype([
    ('id', 'i4'),       # Boundary Tag ID
    ('type', 'i4'),     # 1=Dirichlet, 2=Neumann
    
    # We now store the full set of primitive values for the boundary
    ('rho', 'f8'),      
    ('u',   'f8'),      
    ('v',   'f8'),      
    ('p',   'f8'),
    ('T',   'f8')       # Added T for BC convenience
      
])

# -----------------------------------------------------------------------------
# 3. Sizing Field Sources
# -----------------------------------------------------------------------------

# SOURCES: Regions of influence for mesh refinement.
FIELD_DTYPE = np.dtype([
    ('id', 'i4'),       # Source ID
    ('type', 'i4'),     # Source Type:
                        #   0 = Global Background Size
                        #   1 = Box Region (Requires x1, y1, x2, y2)                       
    ('x1', 'f8'),       # Bounding Box Min X
    ('y1', 'f8'),       # Bounding Box Min Y
    ('x2', 'f8'),       # Bounding Box Max X
    ('y2', 'f8'),       # Bounding Box Max Y
    
    ('v', 'f8')         # Target Element Size (h) inside this region.
                        # The sizing field will create a gradient from this 
                        # value back to the background size.
])
   

# -----------------------------------------------------------------------------
# 4. Fluid State Definitions (New for Phase 3)
# -----------------------------------------------------------------------------

# PRIMITIVE STATE: The variables we usually think about physically.
# Useful for boundary conditions and post-processing visualization.
# PRIMITIVE STATE: Includes T for ease of use in BCs and Viz
PRIMITIVE_DTYPE = np.dtype([
    ('rho', 'f8'),      # Density
    ('u',   'f8'),      # Axial Velocity
    ('v',   'f8'),      # Radial Velocity
    ('p',   'f8'),      # Pressure
    ('T',   'f8')       # Temperature
])

# CONSERVATIVE STATE: The variables actually solved by the Euler equations.
# Used directly in the HLLC Riemann solver loop.
CONSERVATIVE_DTYPE = np.dtype([
    ('rho',   'f8'),    # Mass density
    ('rhou',  'f8'),    # Axial momentum
    ('rhov',  'f8'),    # Radial momentum
    ('rhoE',  'f8')     # Total energy density
])

''' core/data_types.py '''


# BC_DTYPE: Allows the .inp file to define temperature directly


    
